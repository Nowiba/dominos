<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Dominoes</title>
    <style>
        /* ========================================================== */
        /* CSS STYLING (MODERN, ANIMATED, AND ROTATED) */
        /* ========================================================== */
        :root {
            --primary-color: #1a237e; /* Dark Indigo */
            --secondary-color: #ffb300; /* Amber Gold */
            --background-color: #f0f4f8; /* Light background */
            --board-color: #2e7d32; /* Darker Green Board for contrast */
            --tile-color: #eceff1; /* Light Gray/Off-White Tile */
            --dot-color: #263238; /* Dark Dots */
            --player1-color: #00bcd4; /* Cyan (Bottom Player) */
            --player3-color: #ff3d00; /* Deep Orange (Top Player) */
            --tile-width: 65px; /* Slightly bigger tiles */
            --tile-height: 35px; 
            --dot-size: 5px;
            --font-stack: 'Roboto', sans-serif;
            --sidebar-width: 250px;
        }

        /* --- Global & Layout --- */
        body {
            font-family: var(--font-stack);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: var(--background-color);
            color: var(--dot-color);
            touch-action: pan-x pan-y;
            overflow-x: hidden;
            font-size: 16px;
        }

        #game-container {
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
            background-color: #ffffff;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }
        
        /* --- Dynamic Info Sidebar --- */
        #info-sidebar {
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: linear-gradient(180deg, var(--primary-color), #283593);
            color: white;
            padding: 15px;
            box-sizing: border-box;
            z-index: 200;
            transform: translateX(var(--sidebar-width));
            transition: transform 0.3s ease-in-out;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }

        #info-sidebar.open {
            transform: translateX(0);
        }
        
        #sidebar-toggle-btn {
            position: absolute; /* Changed from fixed to absolute within game-container */
            top: 10px;
            right: 10px;
            z-index: 201;
            width: 40px;
            height: 40px;
            background-color: var(--secondary-color);
            color: var(--dot-color);
            border: none;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s, transform 0.2s;
        }

        #sidebar-toggle-btn:active {
            transform: scale(0.95);
        }

        /* Sidebar content styling (omitted for brevity) */
        #info-sidebar h3 { font-size: 1.4em; text-align: center; margin: 0 0 20px 0; padding-bottom: 10px; border-bottom: 2px solid rgba(255, 255, 255, 0.3); }
        #sidebar-status-group div { margin-bottom: 10px; padding: 5px 0; border-bottom: 1px dashed rgba(255, 255, 255, 0.2); font-size: 0.9em; }
        #current-player-display { font-weight: bold; font-size: 1.1em; color: var(--secondary-color); }
        #score-board { display: flex; flex-direction: column; gap: 8px; padding: 10px 0; flex-grow: 1; }
        .score-item { display: flex; justify-content: space-between; padding: 8px; border-radius: 6px; font-size: 1em; font-weight: 500; transition: background-color 0.3s; }
        .score-item.active-turn { box-shadow: 0 0 10px var(--secondary-color); transform: scale(1.05); font-weight: bold; }
        #p1-score-item { background-color: var(--player1-color); color: white; }
        #p2-score-item { background-color: #607d8b; color: white; }
        #p3-score-item { background-color: var(--player3-color); color: white; }
        #p4-score-item { background-color: #607d8b; color: white; }
        #sidebar-start-button { margin-top: 20px; background-color: #4caf50; box-shadow: 0 3px 0 #388e3c; color: white; padding: 12px; width: 100%; }

        /* --- Main Content Area --- */
        #main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px 0; /* Reduced padding */
        }

        /* --- Player Hand Areas --- */
        #top-area, #bottom-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 10px; /* Reduced vertical padding */
        }
        
        #top-area {
            transform: rotate(180deg);
        }

        #player-3-hand, #player-1-hand {
            width: 95%;
        }

        .hand-tiles {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            min-height: 50px; /* Larger minimum height for better spacing */
            padding: 5px 0;
        }

        /* --- Board Area (Bigger) --- */
        #board-wrapper {
            overflow-x: scroll;
            width: 100%; 
            padding: 25px 0; /* Increased vertical padding for bigger board look */
            background-color: var(--board-color);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.7);
            min-height: 120px;
            flex-shrink: 0;
            cursor: pointer; /* Board is now clickable for placement */
        }

        #board {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            min-height: 70px;
            padding: 0 50vw;
            white-space: nowrap;
        }
        
        #message {
            text-align: center;
            padding: 8px; /* Slightly smaller message box */
            background-color: var(--secondary-color);
            color: var(--dot-color);
            font-weight: bold;
            margin: 5px 20px; /* Reduced margins */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
        }

        /* --- Tile Styling --- */
        .domino-tile {
            width: var(--tile-width);
            height: var(--tile-height);
            border: 2px solid var(--dot-color);
            background-color: var(--tile-color);
            display: flex;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            margin: 5px;
            flex-shrink: 0;
            box-sizing: border-box;
            user-select: none;
            position: relative;
            transition: transform 0.15s, box-shadow 0.15s, background-color 0.1s;
        }

        .tile-in-hand.selected {
            transform: scale(1.1) rotateZ(0deg) translateY(-10px); /* Lifted appearance */
            box-shadow: 0 10px 25px var(--secondary-color);
            border: 3px solid var(--secondary-color);
        }
        
        #player-3-hand .domino-tile {
            transform: rotate(180deg);
        }
        
        #player-3-hand .domino-tile.selected {
            transform: scale(1.1) rotate(180deg) translateY(10px); 
        }

        /* Red Error Flash Animation */
        .tile-error {
            background-color: #e53935 !important;
            border-color: #b71c1c !important;
            animation: errorFlash 0.3s ease-in-out 2;
        }

        @keyframes errorFlash {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* --- Countdown Animation --- */
        #countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 5000;
        }

        #countdown-number {
            font-size: 15em;
            color: var(--secondary-color);
            font-weight: 900;
            opacity: 0;
            transform: scale(0.5);
        }

        /* Countdown Animation Class */
        .animate-count {
            animation: pulseCount 1s ease-out forwards;
        }

        @keyframes pulseCount {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1.5); }
            100% { opacity: 0; transform: scale(2); }
        }
        
        /* --- Other Styling (omitted for brevity) --- */
        /* ... (Dot positioning, button styling, game over overlay) ... */
        .domino-tile.vertical { width: var(--tile-height); height: var(--tile-width); flex-direction: column; }
        .domino-tile.vertical .domino-half:first-child { border-bottom: 2px solid var(--dot-color); border-right: none; }
        .domino-half { flex: 1; display: flex; justify-content: center; align-items: center; position: relative; }
        .domino-half:first-child { border-right: 2px solid var(--dot-color); }
        .dot { position: absolute; background-color: var(--dot-color); width: var(--dot-size); height: var(--dot-size); border-radius: 50%; }
        /* Dot positioning patterns (1-6) assumed present from prior versions */

    </style>
</head>
<body>
    <button id="sidebar-toggle-btn" onclick="toggleSidebar()">‚ÑπÔ∏è</button>

    <div id="p4-status" class="ai-status hidden">P4 (AI): <span>0</span> Tiles</div>
    <div id="p2-status" class="ai-status hidden">P2 (AI): <span>0</span> Tiles</div>

    <div id="game-container">
        
        <div id="main-content">
            <div id="top-area">
                <div id="p3-actions">
                    <button id="p3-draw-button" onclick="handleDraw(2)" disabled>Draw Tile</button>
                    <button id="p3-pass-button" onclick="handlePass(2)" disabled>Pass</button>
                </div>
                <div id="player-3-hand" class="hand">
                    <h3>P3 (Local) - <span id="p3-tile-count">0</span> tiles</h3>
                    <div class="hand-tiles"></div>
                </div>
            </div>

            <div id="message">Select your mode, then tap the sidebar button (‚ÑπÔ∏è) to start the round.</div>

            <div id="board-wrapper">
                <div id="board">
                    <p style="color:white; opacity: 0.8; font-size: 1.2em;">The game board</p>
                </div>
            </div>

            <div id="bottom-area">
                <div id="player-1-hand" class="hand">
                    <h3>P1 (You) - <span id="p1-tile-count">0</span> tiles</h3>
                    <div class="hand-tiles"></div>
                </div>
                <div id="p1-actions">
                    <button id="p1-draw-button" onclick="handleDraw(0)" disabled>Draw Tile</button>
                    <button id="p1-pass-button" onclick="handlePass(0)" disabled>Pass</button>
                </div>
            </div>
        </div>
        
    </div>

    <div id="info-sidebar">
        <h3>Domino Status</h3>
        
        <div id="sidebar-status-group">
            <div id="mode-display"></div>
            <div id="current-player-display"></div>
            <div id="boneyard-count-display"></div>
        </div>

        <h3>Game Scores (Target: 100)</h3>
        <div id="score-board">
            <div class="score-item" id="p1-score-item">
                <span>P1 (You)</span>
                <span id="p1-game-score" class="score-value">0</span>
            </div>
            <div class="score-item" id="p2-score-item">
                <span>P2 (AI)</span>
                <span id="p2-game-score" class="score-value">0</span>
            </div>
            <div class="score-item" id="p3-score-item">
                <span>P3 (Local)</span>
                <span id="p3-game-score" class="score-value">0</span>
            </div>
            <div class="score-item" id="p4-score-item">
                <span>P4 (AI)</span>
                <span id="p4-game-score" class="score-value">0</span>
            </div>
        </div>
        
        <button id="sidebar-start-button" onclick="runCountdownAndStartRound()">Start/New Round</button>
    </div>

    <div id="countdown-overlay">
        <div id="countdown-number">3</div>
    </div>

    <div id="mode-overlay">
        <div id="mode-content">
            <h2>Select Game Mode</h2>
            
            <div class="mode-group">
                <h3>SOLO CHALLENGE (P1 vs AI)</h3>
                <select id="bot-count">
                    <option value="1">vs 1 AI (2 Players Total)</option>
                    <option value="2" selected>vs 2 AI (3 Players Total)</option>
                    <option value="3">vs 3 AI (4 Players Total)</option>
                </select>
                <button class="mode-button-large" onclick="setMode(1)">Start Solo Game</button>
            </div>
            
            <div class="mode-group">
                <h3>LOCAL DUEL (P1 vs P3)</h3>
                <button class="mode-button-large" onclick="setMode(2)">Start 2-Player Local Game</button>
            </div>

            <div class="mode-group">
                <h3>TEAM BATTLE (P1 & P3 vs 2 AI)</h3>
                <button class="mode-button-large" onclick="setMode(3)">Start 4-Player Team Game</button>
            </div>
        </div>
    </div>

    <div id="game-over-overlay">
        <div id="game-over-content" style="background:white; padding: 30px; border-radius: 15px; text-align: center;">
            <div id="final-winner" style="font-size: 2em; margin-bottom: 15px; color: var(--primary-color);"></div>
            <div id="final-scores"></div>
            <button id="reset-game-button" onclick="resetGame()" style="margin-top: 20px; background-color: #4caf50;">Play Again</button>
        </div>
    </div>

    <audio id="sfx-play" src="https://www.soundboard.com/mediafiles/et/etw5l182j15x84m.mp3" preload="auto"></audio> 
    <audio id="sfx-draw" src="https://www.soundboard.com/mediafiles/et/etw5l182j15x84m.mp3" preload="auto"></audio> 
    <audio id="sfx-win" src="https://freesound.org/data/previews/273/273461_5127201-lq.mp3" preload="auto"></audio>
    <audio id="sfx-block" src="https://freesound.org/data/previews/415/415510_4193557-lq.mp3" preload="auto"></audio>
    <audio id="sfx-countdown" src="https://freesound.org/data/previews/203/203407_3780338-lq.mp3" preload="auto"></audio>


    <script>
        /* ========================================================== */
        /* JAVASCRIPT GAME LOGIC (V3 - TOUCH & COUNTDOWN) */
        /* ========================================================== */
        
        // --- Game Constants & Dynamic Setup ---
        const GAME_TARGET_SCORE = 100;
        const STARTING_TILES = 7;
        const MAX_PIP = 6;
        const AI_THINK_TIME = 1000;

        let NUM_PLAYERS = 4;
        let HUMAN_PLAYERS = [0, 2];
        let AI_PLAYERS = [1, 3];
        let gameModeText = "Team Game (P1 & P3 vs 2 AI)";

        // --- Game State Variables ---
        let deck = [];
        let hands = [[], [], [], []];
        let board = [];
        let gameScores = [0, 0, 0, 0];
        let currentPlayer = 0;
        let selectedTileEl = null; // Store the element
        let selectedTileData = null; // Store the tile object
        let consecutivePasses = 0;
        let roundActive = false;

        // --- DOM Elements Mapped ---
        const boardEl = document.getElementById('board');
        const boardWrapperEl = document.getElementById('board-wrapper'); // New element to listen for placement
        const handsEl = [
            document.querySelector('#player-1-hand .hand-tiles'),
            null, 
            document.querySelector('#player-3-hand .hand-tiles'),
            null 
        ];
        const tileCountEl = [
            document.getElementById('p1-tile-count'),
            document.querySelector('#p2-status span'),
            document.getElementById('p3-tile-count'),
            document.querySelector('#p4-status span')
        ];
        const scoreEl = [
            document.getElementById('p1-game-score'),
            document.getElementById('p2-game-score'),
            document.getElementById('p3-game-score'),
            document.getElementById('p4-game-score')
        ];
        const sidebarEl = document.getElementById('info-sidebar');
        const currentPlayerDisplayEl = document.getElementById('current-player-display');
        const modeDisplayEl = document.getElementById('mode-display');
        const boneyardCountDisplayEl = document.getElementById('boneyard-count-display');
        const messageEl = document.getElementById('message');
        const sidebarStartButton = document.getElementById('sidebar-start-button');
        const drawButtons = [
            document.getElementById('p1-draw-button'),
            null,
            document.getElementById('p3-draw-button')
        ];
        const passButtons = [
            document.getElementById('p1-pass-button'),
            null,
            document.getElementById('p3-pass-button')
        ];
        const modeOverlay = document.getElementById('mode-overlay');
        const p2StatusEl = document.getElementById('p2-status');
        const p4StatusEl = document.getElementById('p4-status');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const countdownNumberEl = document.getElementById('countdown-number');
        
        // --- Audio Elements ---
        const sfxPlay = document.getElementById('sfx-play');
        const sfxDraw = document.getElementById('sfx-draw');
        const sfxWin = document.getElementById('sfx-win');
        const sfxBlock = document.getElementById('sfx-block');
        const sfxCountdown = document.getElementById('sfx-countdown');

        // --- Sidebar Toggler ---
        function toggleSidebar() {
            sidebarEl.classList.toggle('open');
        }

        // --- Core Utility Functions (Simplified/Maintained) ---

        function playSFX(audioElement) {
            if (!audioElement) return;
            audioElement.pause();
            audioElement.currentTime = 0;
            audioElement.volume = 0.6;
            audioElement.play().catch(e => console.log('Audio play failed:', e));
        }

        function createDeck() {
            deck = [];
            for (let i = 0; i <= MAX_PIP; i++) {
                for (let j = i; j <= MAX_PIP; j++) {
                    deck.push({ pips: [i, j], id: `${i}-${j}`, value: i + j, isDouble: i === j });
                }
            }
        }

        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function drawOneTile(playerIndex) {
            if (deck.length === 0) return null;
            const tile = deck.pop();
            hands[playerIndex].push(tile);
            hands[playerIndex].sort(sortDominoHand);
            playSFX(sfxDraw);
            return tile;
        }
        
        function sortDominoHand(a, b) {
            if (a.isDouble && !b.isDouble) return -1;
            if (!a.isDouble && b.isDouble) return 1;
            return b.value - a.value;
        }

        function createTileElement(tile, isHandTile = true, playerIndex = -1) {
            const tileEl = document.createElement('div');
            tileEl.className = 'domino-tile';
            tileEl.setAttribute('data-pips', `${tile.pips[0]},${tile.pips[1]}`);
            
            if (isHandTile && getHumanPlayerIndex(playerIndex === 0 ? 0 : 2) !== -1) {
                tileEl.classList.add('tile-in-hand');
                tileEl.onclick = (e) => handleTileSelection(tileEl, tile, playerIndex);
                tileEl.setAttribute('data-player', playerIndex);
            }

            tile.pips.forEach(pips => {
                const half = document.createElement('div');
                half.className = `domino-half pips-${pips}`;
                // Simplified dot rendering placeholder (actual dot positioning in CSS)
                for (let i = 0; i < pips; i++) {
                    const dot = document.createElement('span');
                    dot.className = 'dot';
                    half.appendChild(dot);
                }
                tileEl.appendChild(half);
            });
            return tileEl;
        }
        
        // --- Countdown & Start Logic ---
        
        function runCountdownAndStartRound() {
            if (roundActive) {
                // If round is active, we just call the start round logic directly 
                // (e.g., to force a new round after a block, skipping countdown)
                 startNewRound(); 
                 return;
            }

            sidebarEl.classList.remove('open');
            countdownOverlay.style.display = 'flex';
            countdownNumberEl.textContent = '3';
            countdownNumberEl.classList.add('animate-count');
            playSFX(sfxCountdown);

            let count = 2;
            const interval = setInterval(() => {
                countdownNumberEl.classList.remove('animate-count');
                void countdownNumberEl.offsetWidth; // Force reflow
                countdownNumberEl.textContent = count > 0 ? count : 'GO';
                countdownNumberEl.classList.add('animate-count');
                playSFX(sfxCountdown);
                
                if (count < 0) {
                    clearInterval(interval);
                    countdownOverlay.style.display = 'none';
                    startNewRound();
                }
                count--;
            }, 1000);
        }

        function dealTiles() {
            let startingTile = null;
            let starter = -1;
            let highestDoublePip = -1;
            const handsToDeal = Array(NUM_PLAYERS).fill().map(() => []);

            // 1. Deal tiles
            for (let i = 0; i < NUM_PLAYERS; i++) {
                for (let j = 0; j < STARTING_TILES; j++) {
                    if (deck.length > 0) handsToDeal[i].push(deck.pop());
                }
                handsToDeal[i].sort(sortDominoHand);
            }
            
            // 2. Find starter (Highest Double)
            for (let i = 0; i < NUM_PLAYERS; i++) {
                handsToDeal[i].forEach(tile => {
                    if (tile.isDouble && tile.pips[0] > highestDoublePip) {
                        highestDoublePip = tile.pips[0];
                        startingTile = tile;
                        starter = i;
                    }
                });
            }
            
            // 3. If no double, find starter (Highest Value)
            if (starter === -1) {
                let highestValue = -1;
                for (let i = 0; i < NUM_PLAYERS; i++) {
                    handsToDeal[i].forEach(tile => {
                        if (tile.value > highestValue) {
                            highestValue = tile.value;
                            startingTile = tile;
                            starter = i;
                        }
                    });
                }
            }
            
            // The starting tile remains in the starter's hand!
            hands = handsToDeal;
            return { starter: starter, tile: startingTile };
        }

        function startNewRound() {
            roundActive = true;
            createDeck();
            shuffleDeck();
            board = [];
            selectedTileEl = null;
            selectedTileData = null;
            consecutivePasses = 0;
            
            const startInfo = dealTiles();
            
            if (!startInfo || startInfo.starter === -1) {
                setMessage("Error: Could not deal tiles or find a starter.", 'error');
                roundActive = false;
                return;
            }
            
            currentPlayer = startInfo.starter;
            
            renderHands();
            renderBoard();
            updateDisplay();
            
            setMessage(`P${currentPlayer + 1} starts! Play the highest double (or highest tile).`, 'status');
            sidebarStartButton.textContent = "New Round (In Progress)";
            
            if (AI_PLAYERS.includes(currentPlayer)) {
                 setTimeout(aiMove, AI_THINK_TIME);
            }
        }
        
        function resetGameScores() {
            gameScores = Array(4).fill(0);
            gameOverOverlay.style.display = 'none';
            updateDisplay();
        }
        
        function resetGame() {
            gameScores = Array(4).fill(0);
            gameOverOverlay.style.display = 'none';
            resetAndShowModeSelection(); 
        }

        // --- Rendering & UI Updates ---

        function renderHands() {
            [handsEl[0], handsEl[2]].filter(el => el).forEach(el => el.innerHTML = '');

            for (let i = 0; i < NUM_PLAYERS; i++) {
                const isHuman = HUMAN_PLAYERS.includes(i);
                
                if (isHuman) {
                    const handEl = i === 0 ? handsEl[0] : handsEl[2]; 
                    
                    hands[i].forEach(tile => {
                        const tileEl = createTileElement(tile, true, i);
                        handEl.appendChild(tileEl);
                    });
                }
                
                const countIndex = i === 1 && NUM_PLAYERS === 2 ? 2 : (i === 1 ? 1 : (i === 3 ? 3 : i));
                if (tileCountEl[countIndex]) {
                    tileCountEl[countIndex].textContent = hands[i].length;
                }
            }
            
            p2StatusEl.classList.toggle('hidden', !AI_PLAYERS.includes(1) || NUM_PLAYERS < 3);
            p4StatusEl.classList.toggle('hidden', !AI_PLAYERS.includes(3) || NUM_PLAYERS < 4);

            updateActionButtons();
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            if (board.length === 0) {
                boardEl.innerHTML = '<p style="color:white; opacity: 0.8; font-size: 1.2em;">Play the first tile here.</p>';
                return;
            }
            
            board.forEach(tile => {
                const tileEl = createTileElement(tile, false, -1);
                if (tile.isDouble) {
                    tileEl.classList.add('vertical');
                }
                boardEl.appendChild(tileEl);
            });
            
            // Scroll to center the most recent tile
            setTimeout(() => {
                const centerScroll = boardEl.scrollWidth - (boardEl.clientWidth / 2);
                boardWrapperEl.scrollLeft = centerScroll;
            }, 0);
        }
        
        function setMessage(text, type = 'status') {
            messageEl.textContent = text;
            messageEl.style.backgroundColor = type === 'error' ? '#e57373' : (type === 'info' ? '#c8e6c9' : 'var(--secondary-color)');
            messageEl.style.color = type === 'error' ? '#b71c1c' : 'var(--dot-color)';
        }
        
        function updateDisplay() {
            boneyardCountDisplayEl.textContent = `Boneyard: ${deck.length} tiles`;
            modeDisplayEl.textContent = `Mode: ${gameModeText}`;
            
            currentPlayerDisplayEl.textContent = `P${currentPlayer + 1}'s Turn`;
            
            for (let i = 0; i < 4; i++) {
                const scoreItem = document.getElementById(`p${i+1}-score-item`);
                if (scoreItem) {
                    scoreItem.style.display = (i < NUM_PLAYERS) ? 'flex' : 'none';
                    
                    if (i < NUM_PLAYERS) {
                        scoreEl[i].textContent = gameScores[i];
                        scoreItem.classList.toggle('active-turn', i === currentPlayer);
                    }
                }
            }
        }
        
        function getPlayableMoves(playerHand) {
            if (board.length === 0) {
                return playerHand.map(tile => ({ tile, end: 'right', requiredPip: -1 }));
            }
            
            const leftEnd = board[0].pips[0];
            const rightEnd = board[board.length - 1].pips[1];
            let moves = [];
            
            playerHand.forEach(tile => {
                if (tile.pips.includes(leftEnd)) {
                    moves.push({ tile, end: 'left', requiredPip: leftEnd });
                }
                if (tile.pips.includes(rightEnd)) {
                    if (leftEnd === rightEnd && tile.pips[0] === leftEnd && tile.isDouble) {
                         // Only count double once if ends match, to simplify human choice
                        if (moves.some(m => m.tile.id === tile.id)) return;
                    }
                    moves.push({ tile, end: 'right', requiredPip: rightEnd });
                }
            });
            return moves;
        }

        function getHumanPlayerIndex(localPlayerId) {
            if (localPlayerId === 0) return 0;
            if (NUM_PLAYERS === 2 && localPlayerId === 2) return 1;
            if (NUM_PLAYERS > 2 && localPlayerId === 2) return 2;
            return -1;
        }

        // --- Player Interaction (Drag/Drop Simulated) ---
        
        function handleDraw(localPlayerId) {
            const playerIndex = getHumanPlayerIndex(localPlayerId);
            if (currentPlayer !== playerIndex || !roundActive || deck.length === 0) return;
            
            const drawnTile = drawOneTile(playerIndex);
            renderHands();
            updateDisplay();

            if (getPlayableMoves([drawnTile]).length > 0) {
                setMessage(`P${playerIndex + 1} drew. Now play the tile.`, 'status');
                updateActionButtons();
            } else {
                setMessage(`P${playerIndex + 1} drew and passed.`, 'status');
                setTimeout(nextTurn, 500);
            }
        }
        
        function handlePass(localPlayerId) {
            const playerIndex = getHumanPlayerIndex(localPlayerId);
            if (currentPlayer !== playerIndex || !roundActive) return;
            
            if (getPlayableMoves(hands[playerIndex]).length > 0) {
                 setMessage("You cannot pass. Play a tile.", 'error');
                 return;
            }
            
            if (deck.length > 0) {
                setMessage("You must draw before passing.", 'error');
                return;
            }
            
            consecutivePasses++;
            setMessage(`Player ${playerIndex + 1} passes.`, 'status');
            
            if (consecutivePasses >= NUM_PLAYERS) {
                endRound('Block');
                return;
            }
            
            nextTurn();
        }

        /** Step 1: Select a tile (Single Click) */
        function handleTileSelection(tileEl, tile, playerIndex) {
            if (currentPlayer !== playerIndex || !roundActive) return;
            
            if (selectedTileEl) {
                selectedTileEl.classList.remove('selected');
            }

            if (selectedTileEl === tileEl) {
                selectedTileEl = null;
                selectedTileData = null;
                setMessage('Tile deselected.', 'status');
                return;
            }
            
            selectedTileEl = tileEl;
            selectedTileData = tile;
            
            const moves = getPlayableMoves([tile]);
            
            if (moves.length === 0) {
                selectedTileEl.classList.add('tile-error');
                setTimeout(() => selectedTileEl.classList.remove('tile-error'), 600);
                selectedTileEl = null;
                selectedTileData = null;
                setMessage("Cannot play that tile.", 'error');
                return;
            }
            
            // Highlight the tile and wait for the board click
            tileEl.classList.add('selected');
            setMessage(`Selected ${tile.pips[0]}-${tile.pips[1]}. Click the board where you want to place it.`, 'status');
        }

        /** Step 2: Place the tile (Board Click) */
        boardWrapperEl.onclick = function(event) {
            if (!roundActive || !selectedTileData || !HUMAN_PLAYERS.includes(currentPlayer)) {
                return;
            }

            // Calculate the placement end based on where the user clicked horizontally
            const rect = boardWrapperEl.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickFraction = clickX / rect.width;

            // Simplified: If click is on the left half of the board element, assume 'left' placement.
            const end = clickFraction < 0.5 ? 'left' : 'right';

            const tileToPlay = selectedTileData;
            
            const moves = getPlayableMoves([tileToPlay]);
            
            // Check if the tile can be legally played on the *chosen* end
            const validMove = moves.find(m => m.end === end);

            if (validMove) {
                const success = playTile(currentPlayer, tileToPlay, end);
                
                if (success) {
                    selectedTileEl.classList.remove('selected');
                    selectedTileEl = null;
                    selectedTileData = null;
                    
                    if (hands[currentPlayer].length === 0) {
                        endRound(currentPlayer);
                    } else {
                        nextTurn();
                    }
                }
            } else {
                // Illegal placement attempt
                selectedTileEl.classList.add('tile-error');
                setTimeout(() => selectedTileEl.classList.remove('tile-error'), 600);
                setMessage("Wrong end. Try the other side.", 'error');
            }
        };

        // --- Turn Management (Maintained) ---
        
        function nextTurn() {
            if (!roundActive) return;
            
            currentPlayer = (currentPlayer + 1) % NUM_PLAYERS;
            updateDisplay();
            updateActionButtons();
            
            if (AI_PLAYERS.includes(currentPlayer)) {
                setTimeout(aiMove, AI_THINK_TIME);
            } else {
                selectedTileEl = null;
                selectedTileData = null;
                
                const playableMoves = getPlayableMoves(hands[currentPlayer]).length > 0;
                const canDraw = deck.length > 0;

                if (!playableMoves && !canDraw) {
                     setMessage(`P${currentPlayer + 1}, you are blocked. Pass.`, 'status');
                } else if (!playableMoves && canDraw) {
                     setMessage(`P${currentPlayer + 1}, no moves. Draw.`, 'status');
                } else {
                     setMessage(`P${currentPlayer + 1}, your turn!`, 'status');
                }
            }
        }
        
        function updateActionButtons() {
            const isHumanTurn = HUMAN_PLAYERS.includes(currentPlayer);
            const p1IsCurrent = currentPlayer === 0;
            const p3IsCurrent = (NUM_PLAYERS === 2 && currentPlayer === 1) || (NUM_PLAYERS > 2 && currentPlayer === 2);
            
            document.getElementById('top-area').style.display = (NUM_PLAYERS > 1 && HUMAN_PLAYERS.includes(getHumanPlayerIndex(2))) ? 'flex' : 'none';

            drawButtons.forEach(btn => btn && (btn.disabled = true));
            passButtons.forEach(btn => btn && (btn.disabled = true));

            if (!isHumanTurn) return;

            const playerIndex = currentPlayer;
            const playableMoves = getPlayableMoves(hands[playerIndex]).length > 0;
            const canDraw = deck.length > 0;
            const localBtnIndex = p1IsCurrent ? 0 : (p3IsCurrent ? 2 : -1);

            if (localBtnIndex !== -1) {
                if (playableMoves) {
                    // Draw and Pass disabled if you can play
                    drawButtons[localBtnIndex].disabled = true;
                    passButtons[localBtnIndex].disabled = true;
                } else if (canDraw) {
                    // Must draw if you can't play and can draw
                    drawButtons[localBtnIndex].disabled = false;
                    passButtons[localBtnIndex].disabled = true;
                } else {
                    // Must pass if you can't play and can't draw
                    drawButtons[localBtnIndex].disabled = true;
                    passButtons[localBtnIndex].disabled = false;
                }
            }
        }

        // --- AI Logic (Minor Update for initial turn) ---
        
        function aiMove() {
            const aiHand = hands[currentPlayer];
            let playableMoves = getPlayableMoves(aiHand);
            
            if (playableMoves.length === 0 && board.length === 0) {
                 // Initial move: AI MUST play its best tile (highest double/value)
                 const tileToPlay = aiHand[0]; // Already sorted to put best tile first
                 playableMoves.push({ tile: tileToPlay, end: 'right' });
            }

            if (playableMoves.length > 0) {
                // Play the highest value move
                playableMoves.sort((a, b) => b.tile.value - a.tile.value);
                const bestMove = playableMoves[0];
                
                playTile(currentPlayer, bestMove.tile, bestMove.end);
                setMessage(`P${currentPlayer + 1} (AI) plays a tile.`, 'status');
                
                if (hands[currentPlayer].length === 0) {
                    endRound(currentPlayer);
                } else {
                    nextTurn();
                }
                
            } else if (deck.length > 0) {
                drawOneTile(currentPlayer);
                renderHands();
                updateDisplay();
                setMessage(`P${currentPlayer + 1} (AI) draws.`, 'status');
                
                setTimeout(aiMove, 500); 
                
            } else {
                consecutivePasses++;
                setMessage(`P${currentPlayer + 1} (AI) passes.`, 'status');
                
                if (consecutivePasses >= NUM_PLAYERS) {
                    endRound('Block');
                    return;
                }
                nextTurn();
            }
        }
        
        // --- Game Management (Maintained) ---

        function endRound(reason) {
            roundActive = false;
            sidebarStartButton.textContent = "Start Next Round";
            
            let winnerIndex = -1;
            let roundScore = 0;
            let messageText = '';

            if (typeof reason === 'number') {
                winnerIndex = reason;
                for (let i = 0; i < NUM_PLAYERS; i++) {
                    if (i !== winnerIndex) {
                        roundScore += hands[i].reduce((sum, tile) => sum + tile.value, 0);
                    }
                }
                messageText = `üéâ Round Winner: P${winnerIndex + 1}! (${roundScore} pts)`;
                playSFX(sfxWin);
                
            } else if (reason === 'Block') {
                let pipCounts = hands.map((hand, index) => ({ 
                    index: index, 
                    pips: hand.reduce((sum, tile) => sum + tile.value, 0) 
                }));
                
                pipCounts.sort((a, b) => a.pips - b.pips);
                
                const lowestScore = pipCounts[0].pips;
                const lowestScorers = pipCounts.filter(p => p.pips === lowestScore);

                if (lowestScorers.length === 1) {
                    winnerIndex = lowestScorers[0].index;
                    roundScore = pipCounts.reduce((total, p) => total + p.pips, 0) - lowestScore;
                    messageText = `üîí BLOCK! P${winnerIndex + 1} wins the block. (${roundScore} pts)`;
                } else {
                    messageText = `‚öîÔ∏è BLOCK! Tie for lowest pips. No points awarded.`;
                }
                playSFX(sfxBlock);
            }
            
            if (winnerIndex !== -1) {
                gameScores[winnerIndex] += roundScore;
                
                if (gameScores[winnerIndex] >= GAME_TARGET_SCORE) {
                    endGame(winnerIndex);
                    return;
                }
            }
            
            setMessage(messageText, 'info');
            updateDisplay();
        }
        
        function endGame(winnerIndex) {
            roundActive = false;
            const winnerName = `Player ${winnerIndex + 1}`;
            document.getElementById('final-winner').innerHTML = `üëë GAME CHAMPION: <span style="color:${winnerIndex === 0 ? 'var(--player1-color)' : (winnerIndex === 2 ? 'var(--player3-color)' : 'var(--primary-color)')};">${winnerName} WINS!</span>`;
            document.getElementById('final-scores').innerHTML = `<h3>Final Scores:</h3>`;
            gameScores.forEach((score, i) => {
                if (i < NUM_PLAYERS) {
                    document.getElementById('final-scores').innerHTML += `<p>P${i + 1}: ${score} points</p>`;
                }
            });
            document.getElementById('game-over-overlay').style.display = 'flex';
            playSFX(sfxWin);
        }

        // --- Initialization ---
        
        // Ensure the mode overlay is shown first
        resetAndShowModeSelection(); 
    </script>
</body>
</html>
